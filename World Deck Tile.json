{
  "SaveName": "",
  "Date": "",
  "VersionNumber": "",
  "GameMode": "",
  "GameType": "",
  "GameComplexity": "",
  "Tags": [],
  "Gravity": 0.5,
  "PlayArea": 0.5,
  "Table": "",
  "Sky": "",
  "Note": "",
  "TabStates": {},
  "LuaScript": "",
  "LuaScriptState": "",
  "XmlUI": "",
  "ObjectStates": [
    {
      "GUID": "73010e",
      "Name": "Custom_Tile",
      "Transform": {
        "posX": 0.07927724,
        "posY": 1.4814992,
        "posZ": -10.4628582,
        "rotX": -4.71717563E-08,
        "rotY": 180.000122,
        "rotZ": -8.24959159E-08,
        "scaleX": 1.20468616,
        "scaleY": 1.0,
        "scaleZ": 1.20468616
      },
      "Nickname": "World Deck Tile",
      "Description": "",
      "GMNotes": "",
      "AltLookAngle": {
        "x": 0.0,
        "y": 0.0,
        "z": 0.0
      },
      "ColorDiffuse": {
        "r": 1.0,
        "g": 1.0,
        "b": 1.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": false,
      "Grid": true,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "CustomImage": {
        "ImageURL": "https://dl.dropboxusercontent.com/scl/fi/0075xbd8jfs2i91s9uqzh/deckauto.jpg?rlkey=8s2dc2yrv00wv2ydibpd57lnv&dl=0",
        "ImageSecondaryURL": "https://dl.dropboxusercontent.com/scl/fi/63na9l47xwbo056z36z2q/deckauto2.jpg?rlkey=u8p387ovlj5kkog0062vv65kp&dl=0",
        "ImageScalar": 1.0,
        "WidthScale": 0.0,
        "CustomTile": {
          "Type": 3,
          "Thickness": 0.1,
          "Stackable": false,
          "Stretch": true
        }
      },
      "LuaScript": "-- Bundled by luabundle {\"rootModuleName\":\"World Deck Tile.73010e.lua\",\"version\":\"1.6.0\"}\nlocal __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)\n\tlocal loadingPlaceholder = {[{}] = true}\n\n\tlocal register\n\tlocal modules = {}\n\n\tlocal require\n\tlocal loaded = {}\n\n\tregister = function(name, body)\n\t\tif not modules[name] then\n\t\t\tmodules[name] = body\n\t\tend\n\tend\n\n\trequire = function(name)\n\t\tlocal loadedModule = loaded[name]\n\n\t\tif loadedModule then\n\t\t\tif loadedModule == loadingPlaceholder then\n\t\t\t\treturn nil\n\t\t\tend\n\t\telse\n\t\t\tif not modules[name] then\n\t\t\t\tif not superRequire then\n\t\t\t\t\tlocal identifier = type(name) == 'string' and '\\\"' .. name .. '\\\"' or tostring(name)\n\t\t\t\t\terror('Tried to require ' .. identifier .. ', but no such module has been registered')\n\t\t\t\telse\n\t\t\t\t\treturn superRequire(name)\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tloaded[name] = loadingPlaceholder\n\t\t\tloadedModule = modules[name](require, loaded, register, modules)\n\t\t\tloaded[name] = loadedModule\n\t\tend\n\n\t\treturn loadedModule\n\tend\n\n\treturn require, loaded, register, modules\nend)(nil)\n__bundle_register(\"World Deck Tile.73010e.lua\", function(require, _LOADED, __bundle_register, __bundle_modules)\nrequire(\"src/WorldDeckTile\")\nend)\n__bundle_register(\"src/WorldDeckTile\", function(require, _LOADED, __bundle_register, __bundle_modules)\n\r\nrequire(\"src/Config/GeneralConfig\")\r\nrequire(\"src/Utils/HelperFunctions\")\r\n\r\nlocal VisionBackURL = \"http://tts.ledergames.com/Oath/cards/3_2_0/cardbackVision.jpg\"\r\n\r\nlocal map = getObjectFromGUID(GUIDs.map)\r\nif map == nil then\r\n    printToAll(\"ERROR: Cannot find Map by GUID\")\r\nend\r\nlocal worldDeckPosition = getTransformStruct(\"worldDeck\", 0, {position = map.getPosition(), rotation = map.getRotation()})\r\nlocal cachedWorldDeck = nil\r\n\r\nfunction FindWorldDeck()\r\n  if cachedWorldDeck and not cachedWorldDeck.isDestroyed() then\r\n    return cachedWorldDeck\r\n  end\r\n  local hitList = Physics.cast({\r\n    origin = vectorSum(worldDeckPosition.position, vector(0, -1, 0)),\r\n    direction = vector(0, 1, 0),\r\n    type = 1,\r\n    max_distance = 10,\r\n  })\r\n  for _, hit_info in ipairs(hitList) do\r\n    if hit_info.hit_object.type == \"Deck\" then\r\n      cachedWorldDeck = hit_info.hit_object\r\n      return cachedWorldDeck\r\n    end\r\n  end\r\n  return nil\r\nend\r\n\r\nfunction onload(save_str)\r\n  CreateDeckSetupButtons()\r\n  FindWorldDeck()\r\nend\r\n\r\nfunction CreateDeckSetupButtons()\r\n  self.clearButtons()\r\n  local params = {\r\n      click_function = \"OnShuffleFairWorldDeck\",\r\n      function_owner = self,\r\n      label          = \"Randomize\\nNew Deck\",\r\n      position       = {0, 0.1001, 0},\r\n      rotation       = {0, 90, 0},\r\n      width          = 900,\r\n      height         = 1350,\r\n      font_size      = 60,\r\n      color          = {0, 0, 0, 0.35},\r\n      font_color     = {0, 0, 0, 0},\r\n      tooltip        = 'Click to automatically set up deck',\r\n  }\r\n  self.createButton(params)\r\n\r\n  \r\n  local params = {\r\n    click_function = \"OnShuffleUnfairWorldDeck\",\r\n    function_owner = self,\r\n    label          = \"Randomize\\nNew Deck\",\r\n    position       = {0, -0.1001, 0},\r\n    rotation       = {180, 90, 0},\r\n    width          = 900,\r\n    height         = 1350,\r\n    font_size      = 60,\r\n    color          = {0, 0, 0, 0.35},\r\n    font_color     = {0, 0, 0, 0},\r\n    tooltip        = 'Click to automatically set up deck',\r\n  }\r\n  self.createButton(params)\r\nend\r\n\r\n\r\nfunction InsertCardInDeck(deck, card, index)\r\n  local rotation = deck.getRotation()\r\n  local result = nil\r\n  local deckQuantity = deck.getQuantity()\r\n\r\n  if index == 1 then\r\n    -- insert at beginning\r\n    result = group({card, deck})[1]\r\n  elseif index == 2 then\r\n    -- insert at second card\r\n    local frontCard = deck.takeObject({top=true})\r\n    result = group({frontCard, card, deck})[1]\r\n  elseif index == deckQuantity then\r\n    -- insert at second to last card\r\n    local backCard = deck.takeObject({top=false})\r\n    result = group({deck, card, backCard})[1]\r\n  elseif index == deckQuantity + 1 then\r\n    -- insert at end\r\n    result = group({deck, card})[1]\r\n  else\r\n    -- insert somewhere in the middle\r\n    local decks = deck.cut(deckQuantity-(index-1))\r\n    result = group({decks[2], card, decks[1]})[1]\r\n  end\r\n\r\n  -- cutting and grouping can cause the deck to be rotated. This fixes that.\r\n  result.setRotation(rotation)\r\n\r\n  return result\r\nend\r\n\r\n\r\nfunction FindAllVisions()\r\n  local result = {}\r\n  for _, object in ipairs(getAllObjects()) do\r\n    if object.type == 'Card' then\r\n      local cardData = object.getData()\r\n      local deckID = math.floor(cardData.CardID / 100)\r\n      if cardData.CustomDeck[deckID].BackURL == VisionBackURL then\r\n        table.insert(result, object) -- found vision outside deck\r\n      end\r\n    elseif object.type == 'Deck' then\r\n      local deckData = object.getData()\r\n      -- reverse iterate contained objects so that removing from the deck doesn't change indices\r\n      for i = #deckData.ContainedObjects, 1, -1 do\r\n        local info = deckData.ContainedObjects[i]\r\n        local deckID = math.floor(info.CardID / 100)\r\n        if deckData.CustomDeck[deckID].BackURL == VisionBackURL then\r\n          table.insert(result, object.takeObject({index=i-1, smooth=false}))\r\n        end\r\n      end\r\n    end\r\n  end\r\n  return result\r\nend\r\n\r\nfunction ShuffleTable(tbl)\r\n  for i = #tbl, 2, -1 do\r\n    local j = math.random(i)\r\n    tbl[i], tbl[j] = tbl[j], tbl[i]\r\n  end\r\n  return tbl\r\nend\r\n\r\n\r\n-- this will perform world deck setup on the 'A Fair Deck' foundation\r\nfunction OnShuffleFairWorldDeck(_, player_color, _)\r\n\r\n  -- find and shuffle visions\r\n  local visions = ShuffleTable(FindAllVisions())\r\n  if #visions ~= 5 then\r\n    broadcastToAll(\"Error: Could not find all 5 visions!\")\r\n    return\r\n  end\r\n  \r\n  -- find and shuffle world deck\r\n  local worldDeck = FindWorldDeck()\r\n  if worldDeck == nil then\r\n    broadcastToColor(\"World deck not found! Is this a new chronicle? Use the Atlas Portal to generate one.\", player_color, {r=0.8, g=0, b=0})\r\n    return\r\n  end\r\n  worldDeck.shuffle()\r\n\r\n  -- insert visions at random positions according to rules\r\n\r\n  if worldDeck.getQuantity() >= 25 then\r\n    -- two visions go in the first 12 slots\r\n    for i = 1, 2 do\r\n      local index = math.random(1, 10+i)\r\n      visions[i].tooltip = false\r\n      worldDeck = InsertCardInDeck(worldDeck, visions[i], index)\r\n    end\r\n\r\n    -- three visions go between slots 13 and 30\r\n    for i = 3, 5 do\r\n      local index = math.random(13, 27+i)\r\n      visions[i].tooltip = false\r\n      worldDeck = InsertCardInDeck(worldDeck, visions[i], index)\r\n    end\r\n  else\r\n    -- there aren't enough denizens to split the deck. just shuffle it all instead.\r\n    for _, vision in ipairs(visions) do\r\n      local index = math.random(1, worldDeck.getQuantity() + 1)\r\n      vision.tooltip = false\r\n      worldDeck = InsertCardInDeck(worldDeck, vision, index)\r\n    end\r\n  end\r\n\r\nend\r\n\r\n\r\n-- this will perform world deck setup on the 'A Fair Deck' foundation\r\nfunction OnShuffleUnfairWorldDeck(_, player_color, _)\r\n\r\n  -- find and shuffle visions\r\n  local visions = ShuffleTable(FindAllVisions())\r\n  if #visions ~= 5 then\r\n    broadcastToAll(\"Error: Could not find all 5 visions!\")\r\n    return\r\n  end\r\n  \r\n  -- find and shuffle world deck\r\n  local worldDeck = FindWorldDeck()\r\n  if worldDeck == nil then\r\n    broadcastToColor(\"World deck not found! Is this a new chronicle? click the world deck slot to generate one.\", player_color, {r=0.8, g=0, b=0})\r\n    return\r\n  end\r\n  worldDeck.shuffle()\r\n\r\n  -- take one vision out and give it to a random player\r\n  local selectedVision = table.remove(visions, #visions)\r\n  local selectedPlayer = Player.getPlayers()[math.random(#Player.getPlayers())]\r\n  selectedVision.deal(1, selectedPlayer.color)\r\n\r\n  -- insert visions at random positions according to rules\r\n\r\n  if worldDeck.getQuantity() >= 25 then\r\n    -- two visions go in the first 16 slots\r\n    for i = 1, 2 do\r\n      local index = math.random(1, 14+i)\r\n      visions[i].tooltip = false\r\n      worldDeck = InsertCardInDeck(worldDeck, visions[i], index)\r\n    end\r\n\r\n    -- two visions go between slots 17 and 32\r\n    for i = 3, 4 do\r\n      local index = math.random(13, 30+i)\r\n      visions[i].tooltip = false\r\n      worldDeck = InsertCardInDeck(worldDeck, visions[i], index)\r\n    end\r\n  else\r\n    -- there aren't enough denizens to split the deck. just shuffle it all instead.\r\n    for _, vision in ipairs(visions) do\r\n      local index = math.random(1, worldDeck.getQuantity() + 1)\r\n      vision.tooltip = false\r\n      worldDeck = InsertCardInDeck(worldDeck, vision, index)\r\n    end\r\n  end\r\nend\r\n\r\n\nend)\n__bundle_register(\"src/Utils/HelperFunctions\", function(require, _LOADED, __bundle_register, __bundle_modules)\nfunction dataTableContains(table, x)\r\n    for _, obj in ipairs(table) do\r\n        if obj == x then return true end\r\n    end\r\n    return false\r\nend\r\n\r\nfunction getRandomObjectFromContainer(container, flipped)\r\n    local objects = container.getObjects()\r\n    if #objects == 0 then return nil end  -- Prevent errors when bag is empty\r\n    local selected = objects[math.random(1, #objects)]\r\n\r\n    return container.takeObject({\r\n        guid = selected.guid,\r\n        position = vectorSum(container.getPosition(), {x = 0, y = 5, z = 0}),\r\n        rotation = flipped and vectorSum({x = 180, y = 180, z = 0},container.getRotation()) or container.getRotation(),\r\n    })\r\nend\r\n\r\nfunction vectorSum(v1, v2)\r\n    return {\r\n        x = v1.x + v2.x,\r\n        y = v1.y + v2.y,\r\n        z = v1.z + v2.z\r\n    }\r\nend\r\n\r\nfunction removeButtons(...)\r\n    local buttonsToRemove = {...}\r\n    for _, buttonToRemove in ipairs(buttonsToRemove) do\r\n        local buttonIndex = nil\r\n        if self.getButtons() then\r\n            for i, button in ipairs(self.getButtons()) do\r\n                if button and button.label == buttonToRemove.label then\r\n                    buttonIndex = button.index\r\n                    break\r\n                end\r\n            end\r\n            if buttonIndex then self.removeButton(buttonIndex) end\r\n        end\r\n    end\r\nend\r\n\r\nfunction createButtons(...)\r\n    local buttonsToCreate = {...}\r\n    for _, buttonToCreate in ipairs(buttonsToCreate) do\r\n        self.createButton(buttonToCreate)\r\n    end\r\nend\r\n\r\nfunction addTagAndReturn(item, tag)\r\n    item.addTag(tag)\r\n    return item\r\nend\r\n\r\nfunction prettyPrintTable(obj, indent)\r\n    indent = indent or 0\r\n    local formatting = string.rep(\"  \", indent)\r\n\r\n    if type(obj) ~= \"table\" then\r\n        print(formatting .. tostring(obj))\r\n        return\r\n    end\r\n\r\n    print(formatting .. \"{\")\r\n    for key, value in pairs(obj) do\r\n        local key_str = tostring(key)\r\n        if type(value) == \"table\" then\r\n            print(formatting .. \"  \" .. key_str .. \" = \")\r\n            prettyPrintTable(value, indent + 1)\r\n        else\r\n            print(formatting .. \"  \" .. key_str .. \" = \" .. tostring(value))\r\n        end\r\n    end\r\n    print(formatting .. \"}\")\r\nend\r\n\r\n\r\n-- Get transform for a given tag and index\r\n    -- Requires GeneralConfig\r\n    function getTransformStruct(tag, index, baseTransform)\r\n        return {\r\n            position = vectorSum(\r\n                pos[tag](index or 1), \r\n                (baseTransform and baseTransform.position or {x=0,y=0,z=0})\r\n            ),\r\n            rotation = rot[tag],\r\n        }\r\n    end\nend)\n__bundle_register(\"src/Config/GeneralConfig\", function(require, _LOADED, __bundle_register, __bundle_modules)\n-- GUIDs for needed items. IF SOMETHING IS BROKEN LIKELY THESE ARE NO LONGER CORRECT\r\nGUIDs = {\r\n    atlasBox = \"f8bd3c\",\r\n    -- edifices = \"1662f7\",\r\n    relicBag = \"c46336\",\r\n    -- shadowBag = \"1ce44a\",\r\n    siteBag = \"12dafe\",\r\n    table = \"4ee1f2\",\r\n    map = \"d5dacf\",\r\n    dispossessedBag = \"e52b07\",\r\n    archiveDecks = {\r\n        Arcane = \"a79848\",\r\n        Beast = \"d1f201\",\r\n        Discord = \"d40870\",\r\n        Hearth = \"31eab2\",\r\n        Nomad = \"6deb3d\",\r\n        Order = \"275175\"\r\n    },\r\n    foundations = {\r\n      deckSetup = '373c0c'\r\n    },\r\n    scriptingTrigger = '84ebee'\r\n}\r\n\r\n-- Tags to identify items\r\ntags = {\r\n    chronicleCreated = \"chronicleCreated\",\r\n    edifice = \"Edifice\",\r\n    relic = \"Relic\",\r\n    site = \"Site\",\r\n    unlocked = \"Unlocked\",\r\n    protected = \"Protected\"\r\n}\r\n\r\n-- Name strings to use for Atlas Slots depending on their states\r\natlasSlotNames = {\r\n    empty = \"[Empty] Slot\",\r\n    full = \"[Full] Slot\"\r\n}\r\n\r\n-- Tables to track things on the portal\r\nportal = {\r\n    edifices = {},\r\n    relics = {},\r\n    sites = {},\r\n}\r\n\r\n-- Positions\r\npos = {\r\n    -- relative to site\r\n    denizen =       function(i) return {x = 5.35+3.3*i, y = 0.25, z = 0} end,\r\n    relic  =       function(i) return {x = 5.35+3.3*i, y = 0.25, z = 0} end,\r\n    -- relative to atlas portal\r\n    portal =        function(i) return {x = 0, y = 0.10, z = 0} end,\r\n    -- relative to map\r\n    dispossessed =  function(i) return {x = -117.15, y = 0.55, z = 29.15} end,\r\n    relicStack =    function(i) return {x = -19.7, y = 0.55,  z = -9.9} end,\r\n    site =          function(i)\r\n                        local sitePositions = {\r\n                            { x = -26.55, y = 0.21, z =  5.00 },\r\n                            { x = -26.55, y = 0.21, z = -0.75 },\r\n                            { x = -06.10, y = 0.21, z =  5.00 },\r\n                            { x = -06.10, y = 0.21, z = -0.75 },\r\n                            { x = -06.10, y = 0.21, z = -6.50 },\r\n                            { x =  14.85, y = 0.21, z =  5.00 },\r\n                            { x =  14.85, y = 0.21, z = -0.75 },\r\n                            { x =  14.85, y = 0.21, z = -6.50 }\r\n                        }\r\n                        return sitePositions[i]\r\n                    end,\r\n    worldDeck =     function(i) return {x = -14.53, y = 0.55, z = -9.9} end,\r\n}\r\n\r\n-- Rotations\r\nrot = {\r\n    dispossessed =  {x = 0,   y = 180,  z = 180},\r\n    denizen =       {x = 0, y = 180,   z = 0},\r\n    portal =        {x = 0,   y = 180, z = 0},\r\n    relic =         {x = 180, y = 0,   z = 0},\r\n    relicStack =    {x = 180, y = 0,   z = 0},\r\n    site =          {x = 0,   y = 180, z = 0},\r\n    worldDeck =     {x = 0,   y = 90,  z = 180},\r\n}\r\n\r\nsuits = {\"Arcane\",\"Beast\",\"Discord\",\"Hearth\",\"Nomad\",\"Order\"}\r\n\r\nsuitColors = {\r\n    Arcane = '#6f3788',\r\n    Beast = \"#a23723\",\r\n    Discord = \"#33190c\",\r\n    Hearth = \"#e54622\",\r\n    Nomad = \"#49a281\",\r\n    Order = \"#263f86\",\r\n  }\nend)\nreturn __bundle_require(\"World Deck Tile.73010e.lua\")",
      "LuaScriptState": "",
      "XmlUI": ""
    }
  ]
}